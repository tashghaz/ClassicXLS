import SwiftUI
import UniformTypeIdentifiers
import ClassicXLS

struct ContentView: View {
    @State private var headers: [String] = []
    @State private var rows: [[String]] = []
    @State private var alertText: String?
    @State private var showImporter = false
    @State private var showExporter = false
    @State private var sheetName = "Tuners"

    var body: some View {
        VStack(alignment: .leading, spacing: 14) {
            HStack(spacing: 12) {
                Button("Open .xls…") { showImporter = true }
                Button("Export .xls…") {
                    if headers.isEmpty && rows.isEmpty {
                        alertText = "Nothing to export. Open a .xls first."
                    } else {
                        showExporter = true
                    }
                }.disabled(headers.isEmpty && rows.isEmpty)
            }

            Divider()

            Group {
                Text("Sheet: \(sheetName)")
                Text("Headers (B..): \(headers.joined(separator: ", "))")
                    .font(.system(.body, design: .monospaced))
                if rows.isEmpty {
                    Text("No rows loaded yet.").foregroundStyle(.secondary)
                } else {
                    List {
                        ForEach(rows.indices, id: \.self) { i in
                            Text(rows[i].joined(separator: ", "))
                                .font(.system(.body, design: .monospaced))
                        }
                    }
                    .listStyle(.plain)
                }
            }

            Spacer()
        }
        .padding(16)
        .fileImporter(
            isPresented: $showImporter,
            allowedContentTypes: [UTType(filenameExtension: "xls")!],
            allowsMultipleSelection: false
        ) { result in
            switch result {
            case .success(let url): readXLS(url)
            case .failure(let err): alertText = "Open failed: \(err.localizedDescription)"
            }
        }
        .fileExporter(
            isPresented: $showExporter,
            document: ExportXLSDocument(sheetName: sheetName, headers: headers, rows: rows),
            contentType: UTType(filenameExtension: "xls")!,
            defaultFilename: sheetName
        ) { result in
            if case .failure(let err) = result { alertText = "Export failed: \(err.localizedDescription)" }
        }
        .alert("Error", isPresented: .constant(alertText != nil)) {
            Button("OK") { alertText = nil }
        } message: {
            Text(alertText ?? "")
        }
        .frame(minWidth: 560, minHeight: 380)
    }

    // MARK: - Reading

    private func readXLS(_ url: URL) {
        let had = url.startAccessingSecurityScopedResource()
        defer { if had { url.stopAccessingSecurityScopedResource() } }

        DispatchQueue.global(qos: .userInitiated).async {
            do {
                // Prefer your extractor if present:
                // let (h, r) = try XLSGridExtractor.extractTable(from: url, sheetName: sheetName, failOnEmptyCells: false)

                let wb = try XLSReader.read(url: url)
                guard let s = wb.sheets.first(where: { $0.name == sheetName }) ?? wb.sheets.first else {
                    throw NSError(domain: "ClassicXLS.Demo", code: 1, userInfo: [NSLocalizedDescriptionKey:"Sheet '\(sheetName)' not found"])
                }

                var h: [String] = []
                if let headerRow = s.grid[0] {
                    let cols = headerRow.keys.sorted().filter { $0 >= 1 }
                    h = cols.map { c in s.grid[0]?[c].map { stringify($0.value) } ?? "" }
                }

                let cols = (0..<h.count).map { 1 + $0 }
                let rowIdx = s.grid.keys.sorted().filter { $0 >= 1 }
                let r: [[String]] = rowIdx.map { rr in
                    cols.map { cc in s.grid[rr]?[cc].map { stringify($0.value) } ?? "" }
                }.filter { !$0.allSatisfy(\.isEmpty) }

                DispatchQueue.main.async { self.headers = h; self.rows = r }
            } catch {
                DispatchQueue.main.async { self.alertText = error.localizedDescription }
            }
        }
    }

    private func stringify(_ v: XLSValue) -> String {
        switch v {
        case .text(let s):   return s
        case .number(let d): return String(d)
        case .date(let dt):
            let f = DateFormatter(); f.dateFormat = "yyyy-MM-dd"
            return f.string(from: dt)
        }
    }
}